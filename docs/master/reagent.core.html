<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>reagent.core documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Reagent</span> <span class="project-version">0.9.0-SNAPSHOT</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="BatchingAndTiming.html"><div class="inner"><span>Batching and Timing: How Reagent Renders Changes to Application State</span></div></a></li><li class="depth-1 "><a href="CljsjsReactProblems.html"><div class="inner"><span>Question</span></div></a></li><li class="depth-1 "><a href="ComponentNotRerendering.html"><div class="inner"><span>## Question</span></div></a></li><li class="depth-1 "><a href="CreatingReagentComponents.html"><div class="inner"><span>#### Not An Absolute Introduction</span></div></a></li><li class="depth-1 "><a href="InteropWithReact.html"><div class="inner"><span>Interop with React</span></div></a></li><li class="depth-1 "><a href="ManagingState.html"><div class="inner"><span>Managing state: atoms, cursors, Reactions, and tracking</span></div></a></li><li class="depth-1 "><a href="MyAttributesAreMissing.html"><div class="inner"><span>## Question</span></div></a></li><li class="depth-1 "><a href="README.html"><div class="inner"><span># Tutorials</span></div></a></li><li class="depth-1 "><a href="ReactFeatures.html"><div class="inner"><span>React Features</span></div></a></li><li class="depth-1 "><a href="UsingAnEntity.html"><div class="inner"><span>## Question</span></div></a></li><li class="depth-1 "><a href="UsingHiccupToDescribeHTML.html"><div class="inner"><span>Using Hiccup to Describe HTML</span></div></a></li><li class="depth-1 "><a href="UsingRefs.html"><div class="inner"><span>## Question</span></div></a></li><li class="depth-1 "><a href="UsingSquareBracketsInsteadOfParens.html"><div class="inner"><span># Components</span></div></a></li><li class="depth-1 "><a href="WhenDoComponentsUpdate.html"><div class="inner"><span># Components Are Reactive</span></div></a></li><li class="depth-1 "><a href="dangerouslySetInnerHTML.html"><div class="inner"><span>## Question</span></div></a></li><li class="depth-1 "><a href="development.html"><div class="inner"><span>Reagent development</span></div></a></li><li class="depth-1 "><a href="material-ui.html"><div class="inner"><span>Material-UI</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>reagent</span></div></div></li><li class="depth-2 branch current"><a href="reagent.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2 branch"><a href="reagent.debug.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>debug</span></div></a></li><li class="depth-2"><a href="reagent.dom.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>dom</span></div></a></li><li class="depth-3"><a href="reagent.dom.server.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>server</span></div></a></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree" style="top: -52px;"><span class="top" style="height: 61px;"></span><span class="bottom"></span></span><span>impl</span></div></div></li><li class="depth-3 branch"><a href="reagent.impl.batching.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>batching</span></div></a></li><li class="depth-3 branch"><a href="reagent.impl.component.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>component</span></div></a></li><li class="depth-3 branch"><a href="reagent.impl.template.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>template</span></div></a></li><li class="depth-3"><a href="reagent.impl.util.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>util</span></div></a></li><li class="depth-2 branch"><a href="reagent.interop.html"><div class="inner"><span class="tree" style="top: -145px;"><span class="top" style="height: 154px;"></span><span class="bottom"></span></span><span>interop</span></div></a></li><li class="depth-2"><a href="reagent.ratom.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ratom</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="reagent.core.html#var-adapt-react-class"><div class="inner"><span>adapt-react-class</span></div></a></li><li class="depth-1"><a href="reagent.core.html#var-after-render"><div class="inner"><span>after-render</span></div></a></li><li class="depth-1"><a href="reagent.core.html#var-argv"><div class="inner"><span>argv</span></div></a></li><li class="depth-1"><a href="reagent.core.html#var-as-component"><div class="inner"><span>as-component</span></div></a></li><li class="depth-1"><a href="reagent.core.html#var-as-element"><div class="inner"><span>as-element</span></div></a></li><li class="depth-1"><a href="reagent.core.html#var-atom"><div class="inner"><span>atom</span></div></a></li><li class="depth-1"><a href="reagent.core.html#var-children"><div class="inner"><span>children</span></div></a></li><li class="depth-1"><a href="reagent.core.html#var-class-names"><div class="inner"><span>class-names</span></div></a></li><li class="depth-1"><a href="reagent.core.html#var-component-path"><div class="inner"><span>component-path</span></div></a></li><li class="depth-1"><a href="reagent.core.html#var-create-class"><div class="inner"><span>create-class</span></div></a></li><li class="depth-1"><a href="reagent.core.html#var-create-element"><div class="inner"><span>create-element</span></div></a></li><li class="depth-1"><a href="reagent.core.html#var-current-component"><div class="inner"><span>current-component</span></div></a></li><li class="depth-1"><a href="reagent.core.html#var-cursor"><div class="inner"><span>cursor</span></div></a></li><li class="depth-1"><a href="reagent.core.html#var-dispose.21"><div class="inner"><span>dispose!</span></div></a></li><li class="depth-1"><a href="reagent.core.html#var-dom-node"><div class="inner"><span>dom-node</span></div></a></li><li class="depth-1"><a href="reagent.core.html#var-flush"><div class="inner"><span>flush</span></div></a></li><li class="depth-1"><a href="reagent.core.html#var-force-update"><div class="inner"><span>force-update</span></div></a></li><li class="depth-1"><a href="reagent.core.html#var-force-update-all"><div class="inner"><span>force-update-all</span></div></a></li><li class="depth-1"><a href="reagent.core.html#var-is-client"><div class="inner"><span>is-client</span></div></a></li><li class="depth-1"><a href="reagent.core.html#var-merge-props"><div class="inner"><span>merge-props</span></div></a></li><li class="depth-1"><a href="reagent.core.html#var-next-tick"><div class="inner"><span>next-tick</span></div></a></li><li class="depth-1"><a href="reagent.core.html#var-partial"><div class="inner"><span>partial</span></div></a></li><li class="depth-1"><a href="reagent.core.html#var-props"><div class="inner"><span>props</span></div></a></li><li class="depth-1"><a href="reagent.core.html#var-reactify-component"><div class="inner"><span>reactify-component</span></div></a></li><li class="depth-1"><a href="reagent.core.html#var-render"><div class="inner"><span>render</span></div></a></li><li class="depth-1"><a href="reagent.core.html#var-render-component"><div class="inner"><span>render-component</span></div></a></li><li class="depth-1"><a href="reagent.core.html#var-replace-state"><div class="inner"><span>replace-state</span></div></a></li><li class="depth-1"><a href="reagent.core.html#var-rswap.21"><div class="inner"><span>rswap!</span></div></a></li><li class="depth-1"><a href="reagent.core.html#var-set-state"><div class="inner"><span>set-state</span></div></a></li><li class="depth-1"><a href="reagent.core.html#var-state"><div class="inner"><span>state</span></div></a></li><li class="depth-1"><a href="reagent.core.html#var-state-atom"><div class="inner"><span>state-atom</span></div></a></li><li class="depth-1"><a href="reagent.core.html#var-track"><div class="inner"><span>track</span></div></a></li><li class="depth-1"><a href="reagent.core.html#var-track.21"><div class="inner"><span>track!</span></div></a></li><li class="depth-1"><a href="reagent.core.html#var-unmount-component-at-node"><div class="inner"><span>unmount-component-at-node</span></div></a></li><li class="depth-1"><a href="reagent.core.html#var-with-let"><div class="inner"><span>with-let</span></div></a></li><li class="depth-1"><a href="reagent.core.html#var-with-let"><div class="inner"><span>with-let</span></div></a></li><li class="depth-1"><a href="reagent.core.html#var-wrap"><div class="inner"><span>wrap</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">reagent.core</h1><div class="doc"><pre class="plaintext"></pre></div><div class="public anchor" id="var-adapt-react-class"><h3>adapt-react-class</h3><div class="usage"><code>(adapt-react-class c)</code></div><div class="doc"><pre class="plaintext">Returns an adapter for a native React class, that may be used
just like a Reagent component function or class in Hiccup forms.</pre></div></div><div class="public anchor" id="var-after-render"><h3>after-render</h3><div class="usage"><code>(after-render f)</code></div><div class="doc"><pre class="plaintext">Run f using requestAnimationFrame or equivalent.

f will be called just after any queued renders in the next animation
frame (and even if no renders actually occur).</pre></div></div><div class="public anchor" id="var-argv"><h3>argv</h3><div class="usage"><code>(argv this)</code></div><div class="doc"><pre class="plaintext">Returns the entire Hiccup form passed to the component.
</pre></div></div><div class="public anchor" id="var-as-component"><h3>as-component</h3><div class="usage"></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-as-element"><h3>as-element</h3><div class="usage"><code>(as-element form)</code></div><div class="doc"><pre class="plaintext">Turns a vector of Hiccup syntax into a React element. Returns form
unchanged if it is not a vector.</pre></div></div><div class="public anchor" id="var-atom"><h3>atom</h3><div class="usage"><code>(atom x)</code><code>(atom x &amp; rest)</code></div><div class="doc"><pre class="plaintext">Like clojure.core/atom, except that it keeps track of derefs.
Reagent components that derefs one of these are automatically
re-rendered.</pre></div></div><div class="public anchor" id="var-children"><h3>children</h3><div class="usage"><code>(children this)</code></div><div class="doc"><pre class="plaintext">Returns the children passed to a component.
</pre></div></div><div class="public anchor" id="var-class-names"><h3>class-names</h3><div class="usage"><code>(class-names)</code><code>(class-names class)</code><code>(class-names class1 class2)</code><code>(class-names class1 class2 &amp; others)</code></div><div class="doc"><pre class="plaintext">Function which normalizes and combines class values to a string

Reagent allows classes to be defined as:
- Strings
- Named objects (Symbols or Keywords)
- Collections of previous types</pre></div></div><div class="public anchor" id="var-component-path"><h3>component-path</h3><div class="usage"><code>(component-path c)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-create-class"><h3>create-class</h3><div class="usage"><code>(create-class spec)</code></div><div class="doc"><pre class="plaintext">Creates JS class based on provided Clojure map, for example:

```cljs
{:get-initial-state (fn [this])
 :component-will-receive-props (fn [this new-argv])
 :should-component-update (fn [this old-argv new-argv])
 :component-will-mount (fn [this])
 :component-did-mount (fn [this])
 :component-will-update (fn [this new-argv])
 :component-did-update (fn [this old-argv])
 :component-will-unmount (fn [this])
 :reagent-render (fn [args....])}   ;; or :render (fn [this])
```

Everything is optional, except either :reagent-render or :render.

Map keys should use `React.Component` method names (<a href="https://reactjs.org/docs/react-component.html)">https://reactjs.org/docs/react-component.html)</a>,
and can be provided in snake-case or camelCase.
Constructor function is defined using key `:get-initial-state`.

React built-in static methods or properties are automatically defined as statics.</pre></div></div><div class="public anchor" id="var-create-element"><h3>create-element</h3><div class="usage"><code>(create-element type)</code><code>(create-element type props)</code><code>(create-element type props child)</code><code>(create-element type props child &amp; children)</code></div><div class="doc"><pre class="plaintext">Create a native React element, by calling React.createElement directly.

That means the second argument must be a javascript object (or nil), and
that any Reagent hiccup forms must be processed with as-element. For example
like this:

```cljs
(r/create-element "div" #js{:className "foo"}
  "Hi " (r/as-element [:strong "world!"])
```

which is equivalent to

```cljs
[:div.foo "Hi" [:strong "world!"]]
```</pre></div></div><div class="public anchor" id="var-current-component"><h3>current-component</h3><div class="usage"><code>(current-component)</code></div><div class="doc"><pre class="plaintext">Returns the current React component (a.k.a `this`) in a component
function.</pre></div></div><div class="public anchor" id="var-cursor"><h3>cursor</h3><div class="usage"><code>(cursor src path)</code></div><div class="doc"><pre class="plaintext">Provide a cursor into a Reagent atom.

Behaves like a Reagent atom but focuses updates and derefs to
the specified path within the wrapped Reagent atom. e.g.,

```cljs
(let [c (cursor ra [:nested :content])]
  ... @c ;; equivalent to (get-in @ra [:nested :content])
  ... (reset! c 42) ;; equivalent to (swap! ra assoc-in [:nested :content] 42)
  ... (swap! c inc) ;; equivalence to (swap! ra update-in [:nested :content] inc)
  )
```

The first parameter can also be a function, that should look
something like this:

```cljs
(defn set-get
  ([k] (get-in @state k))
  ([k v] (swap! state assoc-in k v)))
```

The function will be called with one argument – the path passed to
cursor – when the cursor is deref'ed, and two arguments (path and
new value) when the cursor is modified.

Given that set-get function, (and that state is a Reagent atom, or
another cursor) these cursors are equivalent:
`(cursor state [:foo])` and `(cursor set-get [:foo])`.

Note that a cursor is lazy: its value will not change until it is
used. This may be noticed with add-watch.</pre></div></div><div class="public anchor" id="var-dispose.21"><h3>dispose!</h3><div class="usage"><code>(dispose! x)</code></div><div class="doc"><pre class="plaintext">Stop the result of track! from updating.
</pre></div></div><div class="public anchor" id="var-dom-node"><h3>dom-node</h3><div class="usage"><code>(dom-node this)</code></div><div class="doc"><pre class="plaintext">Returns the root DOM node of a mounted component.
</pre></div></div><div class="public anchor" id="var-flush"><h3>flush</h3><div class="usage"><code>(flush)</code></div><div class="doc"><pre class="plaintext">Render dirty components immediately to the DOM.

Note that this may not work in event handlers, since React.js does
batching of updates there.</pre></div></div><div class="public anchor" id="var-force-update"><h3>force-update</h3><div class="usage"><code>(force-update this)</code><code>(force-update this deep)</code></div><div class="doc"><pre class="plaintext">Force a component to re-render immediately.

If the second argument is true, child components will also be
re-rendered, even is their arguments have not changed.</pre></div></div><div class="public anchor" id="var-force-update-all"><h3>force-update-all</h3><div class="usage"><code>(force-update-all)</code></div><div class="doc"><pre class="plaintext">Force re-rendering of all mounted Reagent components. This is
probably only useful in a development environment, when you want to
update components in response to some dynamic changes to code.

Note that force-update-all may not update root components. This
happens if a component 'foo' is mounted with `(render [foo])` (since
functions are passed by value, and not by reference, in
ClojureScript). To get around this you'll have to introduce a layer
of indirection, for example by using `(render [#'foo])` instead.</pre></div></div><div class="public anchor" id="var-is-client"><h3>is-client</h3><div class="usage"></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-merge-props"><h3>merge-props</h3><div class="usage"><code>(merge-props)</code><code>(merge-props defaults)</code><code>(merge-props defaults props)</code><code>(merge-props defaults props &amp; others)</code></div><div class="doc"><pre class="plaintext">Utility function that merges some maps, handling `:class` and `:style`.

The :class value is always normalized (using `class-names`) even if no
merging is done.</pre></div></div><div class="public anchor" id="var-next-tick"><h3>next-tick</h3><div class="usage"><code>(next-tick f)</code></div><div class="doc"><pre class="plaintext">Run f using requestAnimationFrame or equivalent.

f will be called just before components are rendered.</pre></div></div><div class="public anchor" id="var-partial"><h3>partial</h3><div class="usage"><code>(partial f &amp; args)</code></div><div class="doc"><pre class="plaintext">Works just like clojure.core/partial, but the result can be compared with =
</pre></div></div><div class="public anchor" id="var-props"><h3>props</h3><div class="usage"><code>(props this)</code></div><div class="doc"><pre class="plaintext">Returns the props passed to a component.
</pre></div></div><div class="public anchor" id="var-reactify-component"><h3>reactify-component</h3><div class="usage"><code>(reactify-component c)</code></div><div class="doc"><pre class="plaintext">Returns an adapter for a Reagent component, that may be used from
React, for example in JSX. A single argument, props, is passed to
the component, converted to a map.</pre></div></div><div class="public anchor" id="var-render"><h3>render</h3><div class="usage"><code>(render comp container)</code><code>(render comp container callback)</code></div><div class="doc"><pre class="plaintext">Render a Reagent component into the DOM. The first argument may be
either a vector (using Reagent's Hiccup syntax), or a React element.
The second argument should be a DOM node.

Optionally takes a callback that is called when the component is in place.

Returns the mounted component instance.</pre></div></div><div class="public anchor" id="var-render-component"><h3>render-component</h3><div class="usage"></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-replace-state"><h3>replace-state</h3><div class="usage"><code>(replace-state this new-state)</code></div><div class="doc"><pre class="plaintext">Set state of a component.
Equivalent to `(reset! (state-atom this) new-state)`</pre></div></div><div class="public anchor" id="var-rswap.21"><h3>rswap!</h3><div class="usage"><code>(rswap! a f &amp; args)</code></div><div class="doc"><pre class="plaintext">Swaps the value of a to be `(apply f current-value-of-atom args)`.

rswap! works like swap!, except that recursive calls to rswap! on
the same atom are allowed – and it always returns nil.</pre></div></div><div class="public anchor" id="var-set-state"><h3>set-state</h3><div class="usage"><code>(set-state this new-state)</code></div><div class="doc"><pre class="plaintext">Merge component state with new-state.
Equivalent to `(swap! (state-atom this) merge new-state)`</pre></div></div><div class="public anchor" id="var-state"><h3>state</h3><div class="usage"><code>(state this)</code></div><div class="doc"><pre class="plaintext">Returns the state of a component, as set with replace-state or set-state.
Equivalent to `(deref (r/state-atom this))`</pre></div></div><div class="public anchor" id="var-state-atom"><h3>state-atom</h3><div class="usage"><code>(state-atom this)</code></div><div class="doc"><pre class="plaintext">Returns an atom containing a components state.
</pre></div></div><div class="public anchor" id="var-track"><h3>track</h3><div class="usage"><code>(track f &amp; args)</code></div><div class="doc"><pre class="plaintext">Takes a function and optional arguments, and returns a derefable
containing the output of that function. If the function derefs
Reagent atoms (or track, etc), the value will be updated whenever
the atom changes.

In other words, `@(track foo bar)` will produce the same result
as `(foo bar)`, but foo will only be called again when the atoms it
depends on changes, and will only trigger updates of components when
its result changes.

track is lazy, i.e the function is only evaluated on deref.</pre></div></div><div class="public anchor" id="var-track.21"><h3>track!</h3><div class="usage"><code>(track! f &amp; args)</code></div><div class="doc"><pre class="plaintext">An eager version of track. The function passed is called
immediately, and continues to be called when needed, until stopped
with dispose!.</pre></div></div><div class="public anchor" id="var-unmount-component-at-node"><h3>unmount-component-at-node</h3><div class="usage"><code>(unmount-component-at-node container)</code></div><div class="doc"><pre class="plaintext">Remove a component from the given DOM node.
</pre></div></div><div class="public anchor" id="var-with-let"><h3>with-let</h3><h4 class="type">macro</h4><div class="usage"><code>(with-let bindings &amp; body)</code></div><div class="doc"><pre class="plaintext">Bind variables as with let, except that when used in a component
the bindings are only evaluated once. Also takes an optional finally
clause at the end, that is executed when the component is
destroyed.</pre></div></div><div class="public anchor" id="var-with-let"><h3>with-let</h3><h4 class="type">macro</h4><div class="usage"><code>(with-let bindings &amp; body)</code></div><div class="doc"><pre class="plaintext">Bind variables as with let, except that when used in a component
the bindings are only evaluated once. Also takes an optional finally
clause at the end, that is executed when the component is
destroyed.</pre></div></div><div class="public anchor" id="var-wrap"><h3>wrap</h3><div class="usage"><code>(wrap value reset-fn &amp; args)</code></div><div class="doc"><pre class="plaintext">Provide a combination of value and callback, that looks like an atom.

The first argument can be any value, that will be returned when the
result is deref'ed.

The second argument should be a function, that is called with the
optional extra arguments provided to wrap, and the new value of the
resulting 'atom'.

Use for example like this:

```cljs
(wrap (:foo @state)
      swap! state assoc :foo)
```

Probably useful only for passing to child components.</pre></div></div></div></body></html>